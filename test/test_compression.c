#include "core/compression.h"
#include "utils/memory.h"

#include <assert.h>
#include <stdio.h>
#include <string.h>

/* ********************************************************************** */
/*                        TESTS WITHOUT CDA_COMPUTE                       */
/* ********************************************************************** */

void test_coap_option_extended(void) {
  uint8_t*     schc_packet = (uint8_t*) pool_alloc(sizeof(uint8_t) * 150);
  const size_t schc_packet_max_byte_len = sizeof(uint8_t) * 150;
  size_t       schc_packet_byte_len;

  /**
   * @brief Perform SCHC compression on packet1 (DI = UP) and packet2 (DI = UP)
   * using short_context.
   *
   * @details The Rule Descriptor which matchs the packet is the 0 and the
   * packet contains many options with CoAP Option Delta and Length Extented.
   */
  const uint8_t short_context[] = {
      // Context
      0, 2, 0, 6, 0, 93,
      // Rule Descriptor
      0x00, 0, 42, 0, 96, 0, 106, 0, 116, 0, 126, 0, 134, 0, 144, 0, 154, 0,
      164, 0, 174, 0, 184, 0, 194, 0, 202, 0, 210, 0, 220, 0, 230, 0, 240, 0,
      250, 0x01, 0x06, 0x01, 0x0e, 0x01, 0x18, 0x01, 0x22, 0x01, 0x2a, 0x01,
      0x34, 0x01, 0x3e, 0x01, 0x48, 0x01, 0x52, 0x01, 0x5c, 0x01, 0x6a, 0x01,
      0x74, 0x01, 0x7c, 0x01, 0x84, 0x01, 0x8e, 0x01, 0x98, 0x01, 0xa2, 0x01,
      0xac, 0x01, 0xb6, 0x01, 0xc0, 0x01, 0xc8, 0x01, 0xd2, 0x01, 0xdc, 0x01,
      0xe6, 0x01, 0xee,  // Rule for compression
      // 93
      0x01, 1, 0,  // Rule for no-compression
      // Rule Field Descriptor
      0x13, 0xcc, 0, 4, 0, 1, 64, 1, 0x01, 0xf8,   // sid-ipv6-version
                                                   // bi/eq/ns
      0x13, 0xc9, 0, 8, 0, 1, 64, 1, 0x01, 0xf9,   // sid-ipv6-trafficclass
                                                   // bi/eq/ns
      0x13, 0xc5, 0, 20, 0, 1, 0, 1, 0x01, 0xfa,   // sid-ipv6-flow-label
                                                   // up/eq/ns
      0x13, 0xc8, 0, 16, 0, 1, 75, 0,              // sid-ipv6-payload-length
                                                   // bi/ig/vs
      0x13, 0xc7, 0, 8, 0, 1, 64, 1, 0x01, 0xfd,   // sid-ipv6-nextheader
                                                   // bi/eq/ns
      0x13, 0xc6, 0, 8, 0, 1, 64, 1, 0x01, 0xfe,   // sid-ipv6-hop-limit
                                                   // bi/eq/ns
      0x13, 0xc1, 0, 128, 0, 1, 0, 1, 0x01, 0xff,  // sid-ipv6-sourceaddress
                                                   // up/eq/ns
      0x13, 0xc4, 0, 128, 0, 1, 0, 1, 0x02,
      0x0f,                                       // sid-ipv6-destinationaddress
                                                  // up/eq/ns
      0x13, 0xce, 0, 16, 0, 1, 0, 1, 0x02, 0x1f,  // sid-udp-app-port
                                                  // up/eq/ns
      0x13, 0xd1, 0, 16, 0, 1, 0, 1, 0x02, 0x21,  // sid-udp-dev-port
                                                  // up/eq/ns
      0x13, 0xd2, 0, 16, 0, 1, 75, 0,             // sid-udp-length
                                                  // bi/ig/vs
      0x13, 0xd0, 0, 16, 0, 1, 75, 0,             // sid-udp-checksum
                                                  // bi/ig/vs
      0x13, 0xbf, 0, 2, 0, 1, 64, 1, 0x02, 0x23,  // sid-coap-version (0x01)
                                                  // bi/eq/ns
      0x13, 0xbe, 0, 2, 0, 1, 0, 1, 0x01, 0xf9,   // sid-coap-type (0x00)
                                                  // up/eq/ns
      0x13, 0xbc, 0, 4, 0, 1, 0, 1, 0x02, 0x24,   // sid-coap-tkl (0x08)
                                                  // up/eq/ns
      0x13, 0x9f, 0, 8, 0, 1, 0, 1, 0x02, 0x25,   // sid-coap-code (0x02)
                                                  // up/eq/ns
      0x13, 0xa2, 0, 16, 0, 1, 17, 0, 10, 1, 0x02, 0x25,  // sid-coap-mid (0x02,
                                                          // 0x12) up/msb/lsb
      0x13, 0xbd, 0, 0, 0, 1, 11, 0,                      // sid-coap-token
                                                          // up/ig/vs
      0x14, 0x10, 0, 4, 0, 1, 0, 1, 0x02, 0x27,  // sid-option-delta (0x0b)
                                                 // up/eq/ns
      0x14, 0x12, 0, 4, 0, 1, 0, 1, 0x02, 0x25,  // sid-option-length (0x02)
                                                 // up/eq/ns
      0x14, 0x14, 0, 0, 0, 1, 11, 0,             // sid-option-value
                                                 // up/ig/vs
      0x14, 0x10, 0, 4, 0, 1, 0, 1, 0x02, 0x23,  // sid-option-delta (0x01)
                                                 // up/eq/ns
      0x14, 0x12, 0, 4, 0, 1, 0, 1, 0x02, 0x23,  // sid-option-length (0x01)
                                                 // up/eq/ns
      0x14, 0x14, 0, 0, 0, 1, 0, 1, 0x02, 0x28,  // sid-option-value (0x28) ???
                                                 // len=8 up/eq/ns
      0x14, 0x10, 0, 4, 0, 1, 0, 1, 0x02, 0x29,  // sid-option-delta (0x03)
                                                 // up/eq/ns
      0x14, 0x12, 0, 4, 0, 1, 0, 1, 0x02, 0x29,  // sid-option-length (0x03)
                                                 // up/eq/ns
      0x14, 0x14, 0, 0, 0, 1, 26, 3, 0x02, 0x2a, 0x02, 0x2d, 0x02,
      0x30,  // sid-option-value (??len=24) (0x62, 0x3d, 0x55 or 0xab, 0xcd,
             // 0xef or 0x77, 0x00, 0xff) up/map/map
      0x14, 0x10, 0, 4, 0, 1, 0, 1, 0x01, 0xf9,  // sid-option-delta (0x00)
                                                 // up/eq/ns
      0x14, 0x12, 0, 4, 0, 1, 11, 0,             // sid-option-length
                                                 // up/ig/vs
      0x14, 0x14, 0, 0, 0, 1, 11, 0,             // sid-option-value
                                                 // up/ig/vs
      0x14, 0x10, 0, 4, 0, 1, 0, 1, 0x01, 0xf9,  // sid-option-delta (0x00)
                                                 // up/eq/ns
      0x14, 0x12, 0, 4, 0, 1, 0, 1, 0x01, 0xf8,  // sid-option-length (0x06)
                                                 // up/eq/ns
      0x14, 0x14, 0, 0, 0, 1, 0, 1, 0x02,
      0x33,  // sid-option-value (0x6c,0x74,0x3d,0x33,0x30,0x30)
             // up/eq/ns
      0x14, 0x10, 0, 4, 0, 1, 0, 1, 0x01, 0xf9,  // sid-option-delta (0x00)
                                                 // up/eq/ns
      0x14, 0x12, 0, 4, 0, 1, 0, 1, 0x02, 0x39,  // sid-option-length (0x0d)
                                                 // up/eq/ns
      0x14, 0x13, 0, 0, 0, 1, 0, 1, 0x02, 0x25,  // sid-option-length-extended
                                                 // (0x02) (???len=8) up/eq/ns
      0x14, 0x14, 0, 0, 0, 1, 11, 0,             // sid-option-value
                                                 // up/ig/vs
      0x14, 0x10, 0, 4, 0, 1, 0, 1, 0x02, 0x39,  // sid-option-delta (0x0d)
                                                 // up/eq/ns
      0x14, 0x12, 0, 4, 0, 1, 0, 1, 0x02, 0x25,  // sid-option-length (0x02)
                                                 // up/eq/ns
      0x14, 0x11, 0, 0, 0, 1, 0, 1, 0x02, 0x3a,  // sid-option-delta-extended
                                                 // (0x14) (???len=8) up/eq/ns
      0x14, 0x14, 0, 0, 0, 1, 11, 0,             // sid-option-value
                                                 // up/ig/vs
      0x14, 0x15, 0, 8, 0, 1, 0, 1, 0x02, 0x3b,  // sid-payload-marker (0xff)
                                                 // up/eq/ns
      // Target Value
      0x06,              // IPv6 Version
      0x00,              // IPv6 Traffic class + CoAP Type + Option Del 4/5/6
      0x0f, 0xf8, 0x5f,  // IPv6 Flow Label
      0x11,              // IPv6 Next Header
      0x40,              // IPv6 Hop Limit
      0x20, 0x01, 0x0d, 0xb8, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x03,  // IPv6 Addr SRC
      0x20, 0x01, 0x0d, 0xb8, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x20,  // IPv6 Addr DST
      0x90, 0xa0,              // UDP App Port
      0x16, 0x33,              // UDP Dev Port
      0x01,                    // CoAP Version + (Option DEL+LEN 2)
      0x08,                    // CoAP TKL
      0x02,                    // CoAP Code + Option LEN 1/7 + LEN-EXT 6
      0x12,                    // following part of CoAP MID
      0x0b,                    // Option DEL 1
      0x28,                    // Option VAL 2
      0x03,                    // Option DEL 3 + LEN 3
      0x62, 0x3d, 0x55,        // Option VAL 3
      0xab, 0xcd, 0xef,        // Option VAL 3
      0x77, 0x00, 0xff,        // Option VAL 3
      0x6c, 0x74, 0x3d, 0x33, 0x30, 0x30,  // Option VAL 5
      0x0d,                                // Option LEN 6 + DEL 7
      0x14,                                // Option DEL-EXT 7
      0xff                                 // Payload maker
  };
  const size_t short_context_byte_len = sizeof(short_context);

  const uint8_t packet1[] = {
      0x60, 0x0f, 0xf8, 0x5f, 0x00, 0x1d, 0x11, 0x40, 0x20, 0x01, 0x0d, 0xb8,
      0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
      0x20, 0x01, 0x0d, 0xb8, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x20, 0x90, 0xa0, 0x16, 0x33, 0x00, 0x1d, 0x13, 0xed,
      0x48, 0x02, 0x84, 0x99, 0x74, 0xcd, 0xe8, 0xcb, 0x4e, 0x8c, 0x0d, 0xb7,
      0xb2, 0x72, 0x64, 0x11, 0x28, 0x33, 0x62, 0x3d, 0x55, 0x09, 0x6c, 0x77,
      0x6d, 0x32, 0x6d, 0x3d, 0x31, 0x2e, 0x31, 0x06, 0x6c, 0x74, 0x3d, 0x33,
      0x30, 0x30, 0x0d, 0x02, 0x65, 0x70, 0x3d, 0x38, 0x35, 0x62, 0x61, 0x39,
      0x62, 0x64, 0x61, 0x63, 0x30, 0x62, 0x65, 0xd2, 0x14, 0x07, 0x2b, 0xff,
      0x68, 0X33, 0X6c, 0X6c, 0X30, 0X0a};
  const size_t packet1_byte_len = sizeof(packet1);

  const uint8_t expected_schc_packet1[] = {
      0x00, 0x0e, 0x80, 0x0e, 0x89, 0xf6, 0xb3, 0xe8, 0x0e, 0x99, 0xbd, 0x19,
      0x69, 0xd1, 0x81, 0xb6, 0xfe, 0x20, 0xe4, 0xc8, 0x4f, 0xa4, 0x36, 0x3b,
      0xb6, 0x99, 0x36, 0x9e, 0x98, 0x97, 0x18, 0xfb, 0xc3, 0x2b, 0x81, 0xe9,
      0xc1, 0xab, 0x13, 0x09, 0xcb, 0x13, 0x23, 0x0b, 0x19, 0x83, 0x13, 0x2f,
      0x88, 0x03, 0x95, 0xb4, 0x19, 0xb6, 0x36, 0x18, 0x05, 0x00};
  const size_t expected_schc_packet1_byte_len = sizeof(expected_schc_packet1);

  schc_packet_byte_len =
      compress(schc_packet, schc_packet_max_byte_len, DI_UP, packet1,
               packet1_byte_len, short_context, short_context_byte_len);

  assert(schc_packet_byte_len == expected_schc_packet1_byte_len);
  assert(memcmp(schc_packet, expected_schc_packet1, schc_packet_byte_len) == 0);

  const uint8_t packet2[] = {
      0x60, 0x0f, 0xf8, 0x5f, 0x00, 0x1d, 0x11, 0x40, 0x20, 0x01, 0x0d, 0xb8,
      0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
      0x20, 0x01, 0x0d, 0xb8, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x20, 0x90, 0xa0, 0x16, 0x33, 0x00, 0x1d, 0x13, 0xed,
      0x48, 0x02, 0x84, 0x9f, 0x74, 0xcd, 0xe8, 0xcb, 0x4e, 0x8c, 0x0d, 0xb7,
      0xb2, 0x72, 0x64, 0x11, 0x28, 0x33, 0x77, 0x00, 0xff, 0x09, 0x6c, 0x77,
      0x6d, 0x32, 0x6d, 0x3d, 0x31, 0x2e, 0x31, 0x06, 0x6c, 0x74, 0x3d, 0x33,
      0x30, 0x30, 0x0d, 0x02, 0x65, 0x77, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45,
      0x62, 0x64, 0x61, 0x63, 0x30, 0x62, 0x65, 0xd2, 0x14, 0x07, 0x2b, 0xff,
      0x6f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x3c, 0x33};
  const size_t packet2_byte_len = sizeof(packet2);

  const uint8_t expected_schc_packet2[] = {
      0x00, 0x0e, 0x80, 0x0e, 0x89, 0xf6, 0xbf, 0xe8, 0x0e, 0x99, 0xbd, 0x19,
      0x69, 0xd1, 0x81, 0xb6, 0xfe, 0x20, 0xe4, 0xc9, 0x4f, 0xa4, 0x36, 0x3b,
      0xb6, 0x99, 0x36, 0x9e, 0x98, 0x97, 0x18, 0xfb, 0xc3, 0x2b, 0xbd, 0x5e,
      0x6f, 0x78, 0x09, 0x1a, 0x2b, 0x13, 0x23, 0x0b, 0x19, 0x83, 0x13, 0x2f,
      0x88, 0x03, 0x95, 0xb7, 0xb9, 0x30, 0xb7, 0x33, 0xb2, 0x9e, 0x19, 0x80};
  const size_t expected_schc_packet2_byte_len = sizeof(expected_schc_packet2);

  schc_packet_byte_len =
      compress(schc_packet, schc_packet_max_byte_len, DI_UP, packet2,
               packet2_byte_len, short_context, short_context_byte_len);

  assert(schc_packet_byte_len == expected_schc_packet2_byte_len);
  assert(memcmp(schc_packet, expected_schc_packet2, schc_packet_byte_len) == 0);

  pool_dealloc(schc_packet, schc_packet_max_byte_len);
}

/* ********************************************************************** */
/*                         TESTS WITH CDA_COMPUTE                         */
/* ********************************************************************** */

void test_rule_descriptor_0(const uint8_t* context,
                            const size_t   context_byte_len);
void test_rule_descriptor_1(const uint8_t* context,
                            const size_t   context_byte_len);
void test_rule_descriptor_2(const uint8_t* context,
                            const size_t   context_byte_len);
void test_rule_descriptor_3(const uint8_t* context,
                            const size_t   context_byte_len);
void test_rule_descriptor_4(const uint8_t* context,
                            const size_t   context_byte_len);

/* ********************************************************************** */

void test_with_compute(void) {
  const uint8_t context[] = {
      // Context
      0, 5, 0, 12, 0, 89, 0, 166, 0, 243, 1, 64,

      // Rule Descriptors
      0, 0, 37, 1, 67, 1, 77, 1, 93, 1, 109, 1, 117, 1, 127, 1, 137, 1, 147, 1,
      157, 1, 167, 1, 177, 1, 187, 1, 197, 1, 207, 1, 217, 1, 225, 1, 233, 1,
      243, 1, 253, 2, 7, 2, 17, 2, 37, 2, 45, 2, 55, 2, 65, 2, 73, 2, 83, 2, 93,
      2, 107, 2, 117, 2, 127, 2, 65, 2, 137, 2, 55, 2, 147, 2, 65, 2,
      157,  // Rule Descriptor n° 0
      1, 0, 37, 1, 67, 2, 167, 1, 93, 1, 109, 1, 117, 1, 127, 1, 137, 1, 147, 1,
      157, 1, 167, 1, 177, 1, 187, 1, 197, 1, 207, 1, 217, 1, 225, 1, 233, 1,
      243, 1, 253, 2, 7, 2, 179, 2, 37, 2, 45, 2, 55, 2, 65, 2, 73, 2, 83, 2,
      93, 2, 107, 2, 117, 2, 127, 2, 65, 2, 137, 2, 55, 2, 147, 2, 65, 2,
      157,  // Rule Descriptor n° 1
      2, 0, 37, 1, 67, 2, 191, 1, 93, 1, 109, 1, 117, 1, 127, 1, 137, 1, 147, 1,
      157, 1, 167, 1, 177, 1, 187, 1, 197, 1, 207, 1, 217, 1, 225, 1, 233, 1,
      243, 1, 253, 2, 7, 2, 199, 2, 37, 2, 45, 2, 55, 2, 65, 2, 73, 2, 83, 2,
      93, 2, 107, 2, 117, 2, 127, 2, 65, 2, 137, 2, 55, 2, 147, 2, 65, 2,
      157,  // Rule Descriptor n° 2
      3, 0, 37, 1, 67, 2, 191, 2, 207, 1, 109, 1, 117, 1, 127, 1, 137, 1, 147,
      1, 157, 1, 167, 1, 177, 1, 187, 1, 197, 1, 207, 1, 217, 1, 225, 2, 215, 2,
      223, 2, 231, 2, 239, 2, 199, 2, 37, 2, 247, 2, 255, 2, 65, 2, 247, 2, 255,
      2, 65, 2, 247, 2, 255, 3, 7, 2, 65, 2, 247, 2, 255, 3, 15, 2, 65, 2,
      157,      // Rule Descriptor n° 3
      4, 1, 0,  // Rule Descriptor n° 4

      // Rule Field Descriptors
      0x13, 0xcc, 0x0, 0x4, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x17,  // Rule Field Descriptor n° 0
      0x13, 0xc9, 0x0, 0x8, 0x0, 0x1, 0x5a, 0x4, 0x3, 0x18, 0x3, 0x19, 0x3,
      0x1a, 0x3, 0x1b,  // Rule Field Descriptor n° 1
      0x13, 0xc5, 0x0, 0x14, 0x0, 0x1, 0x5a, 0x4, 0x3, 0x1c, 0x3, 0x1f, 0x3,
      0x22, 0x3, 0x25,  // Rule Field Descriptor n° 2
      0x13, 0xc8, 0x0, 0x10, 0x0, 0x1, 0x4c, 0x0,  // Rule Field Descriptor n° 3
      0x13, 0xc7, 0x0, 0x8, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x28,  // Rule Field Descriptor n° 4
      0x13, 0xc6, 0x0, 0x8, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x29,  // Rule Field Descriptor n° 5
      0x13, 0xc1, 0x0, 0x80, 0x0, 0x1, 0x0, 0x1, 0x3,
      0x2a,  // Rule Field Descriptor n° 6
      0x13, 0xc1, 0x0, 0x80, 0x0, 0x1, 0x20, 0x1, 0x3,
      0x3a,  // Rule Field Descriptor n° 7
      0x13, 0xc4, 0x0, 0x80, 0x0, 0x1, 0x0, 0x1, 0x3,
      0x3a,  // Rule Field Descriptor n° 8
      0x13, 0xc4, 0x0, 0x80, 0x0, 0x1, 0x20, 0x1, 0x3,
      0x2a,  // Rule Field Descriptor n° 9
      0x13, 0xce, 0x0, 0x10, 0x0, 0x1, 0x0, 0x1, 0x3,
      0x4a,  // Rule Field Descriptor n° 10
      0x13, 0xce, 0x0, 0x10, 0x0, 0x1, 0x20, 0x1, 0x3,
      0x4c,  // Rule Field Descriptor n° 11
      0x13, 0xd1, 0x0, 0x10, 0x0, 0x1, 0x0, 0x1, 0x3,
      0x4c,  // Rule Field Descriptor n° 12
      0x13, 0xd1, 0x0, 0x10, 0x0, 0x1, 0x20, 0x1, 0x3,
      0x4a,  // Rule Field Descriptor n° 13
      0x13, 0xd2, 0x0, 0x10, 0x0, 0x1, 0x4c,
      0x0,  // Rule Field Descriptor n° 14
      0x13, 0xd0, 0x0, 0x10, 0x0, 0x1, 0x4c,
      0x0,  // Rule Field Descriptor n° 15
      0x13, 0xbf, 0x0, 0x2, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x4e,  // Rule Field Descriptor n° 16
      0x13, 0xbe, 0x0, 0x2, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x4f,  // Rule Field Descriptor n° 17
      0x13, 0xbc, 0x0, 0x4, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x50,  // Rule Field Descriptor n° 18
      0x13, 0x9f, 0x0, 0x8, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x51,  // Rule Field Descriptor n° 19
      0x13, 0xa2, 0x0, 0x10, 0x0, 0x1, 0x5a, 0x6, 0x3, 0x52, 0x3, 0x54, 0x3,
      0x56, 0x3, 0x58, 0x3, 0x5a, 0x3, 0x5c,  // Rule Field Descriptor n° 20
      0x13, 0xbd, 0x0, 0x0, 0x0, 0x1, 0x4b, 0x0,  // Rule Field Descriptor n° 21
      0x14, 0x10, 0x0, 0x4, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x5e,  // Rule Field Descriptor n° 22
      0x14, 0x12, 0x0, 0x4, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x5f,  // Rule Field Descriptor n° 23
      0x14, 0x14, 0x0, 0x0, 0x0, 0x1, 0x4b, 0x0,  // Rule Field Descriptor n° 24
      0x14, 0x10, 0x0, 0x4, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x60,  // Rule Field Descriptor n° 25
      0x14, 0x12, 0x0, 0x4, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x60,  // Rule Field Descriptor n° 26
      0x14, 0x14, 0x0, 0x0, 0x0, 0x1, 0x5a, 0x3, 0x3, 0x61, 0x3, 0x64, 0x3,
      0x67,  // Rule Field Descriptor n° 27
      0x14, 0x10, 0x0, 0x4, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x6a,  // Rule Field Descriptor n° 28
      0x14, 0x12, 0x0, 0x4, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x6b,  // Rule Field Descriptor n° 29
      0x14, 0x13, 0x0, 0x0, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x51,  // Rule Field Descriptor n° 30
      0x14, 0x10, 0x0, 0x4, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x6b,  // Rule Field Descriptor n° 31
      0x14, 0x11, 0x0, 0x0, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x6c,  // Rule Field Descriptor n° 32
      0x14, 0x15, 0x0, 0x8, 0x0, 0x1, 0x40, 0x1, 0x3,
      0x18,  // Rule Field Descriptor n° 33
      0x13, 0xc9, 0x0, 0x8, 0x0, 0x1, 0x51, 0x0, 0x4, 0x1, 0x3,
      0x6d,  // Rule Field Descriptor n° 34
      0x13, 0xa2, 0x0, 0x10, 0x0, 0x1, 0x51, 0x0, 0xa, 0x1, 0x3,
      0x6e,  // Rule Field Descriptor n° 35
      0x13, 0xc9, 0x0, 0x8, 0x0, 0x1, 0x4b, 0x0,  // Rule Field Descriptor n° 36
      0x13, 0xa2, 0x0, 0x10, 0x0, 0x1, 0x4b,
      0x0,  // Rule Field Descriptor n° 37
      0x13, 0xc5, 0x0, 0x14, 0x0, 0x1, 0x4b,
      0x0,  // Rule Field Descriptor n° 38
      0x13, 0xbf, 0x0, 0x2, 0x0, 0x1, 0x4b, 0x0,  // Rule Field Descriptor n° 39
      0x13, 0xbe, 0x0, 0x2, 0x0, 0x1, 0x4b, 0x0,  // Rule Field Descriptor n° 40
      0x13, 0xbc, 0x0, 0x4, 0x0, 0x1, 0x4b, 0x0,  // Rule Field Descriptor n° 41
      0x13, 0x9f, 0x0, 0x8, 0x0, 0x1, 0x4b, 0x0,  // Rule Field Descriptor n° 42
      0x14, 0x10, 0x0, 0x4, 0x0, 0x1, 0x4b, 0x0,  // Rule Field Descriptor n° 43
      0x14, 0x12, 0x0, 0x4, 0x0, 0x1, 0x4b, 0x0,  // Rule Field Descriptor n° 44
      0x14, 0x13, 0x0, 0x0, 0x0, 0x1, 0x4b, 0x0,  // Rule Field Descriptor n° 45
      0x14, 0x11, 0x0, 0x0, 0x0, 0x1, 0x4b, 0x0,  // Rule Field Descriptor n° 46

      // Target Values
      0x6, 0xff, 0xfe, 0xf1, 0xf7, 0x0, 0xef, 0x2d, 0xf, 0xfe, 0x2d, 0x7, 0x77,
      0x77, 0xf, 0xf8, 0x5f, 0x11, 0x40, 0x20, 0x1, 0xd, 0xb8, 0x0, 0xa, 0x0,
      0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x20, 0x1, 0xd, 0xb8, 0x0,
      0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0xd1, 0x0, 0x16,
      0x33, 0x1, 0x0, 0x8, 0x2, 0x84, 0x81, 0x84, 0x82, 0x84, 0x83, 0x84, 0x84,
      0x84, 0x85, 0x84, 0x86, 0xb, 0x2, 0x3, 0x62, 0x3d, 0x55, 0xab, 0xcd, 0xef,
      0x77, 0x0, 0xff, 0x0, 0xd, 0x14, 0xf, 0x2, 0x12};
  const size_t context_byte_len = sizeof(context);

  test_rule_descriptor_0(context, context_byte_len);
  test_rule_descriptor_1(context, context_byte_len);
  test_rule_descriptor_2(context, context_byte_len);
  test_rule_descriptor_3(context, context_byte_len);
  test_rule_descriptor_4(context, context_byte_len);
}

/* ********************************************************************** */

void test_rule_descriptor_0(const uint8_t* context,
                            const size_t   context_byte_len) {
  uint8_t*     schc_packet = (uint8_t*) pool_alloc(sizeof(uint8_t) * 100);
  const size_t schc_packet_max_byte_len = sizeof(uint8_t) * 100;
  size_t       schc_packet_byte_len;

  /**
   * @brief Perform SCHC compression on packet (DI = UP) using context.
   *
   * @details The Rule Descriptor which matchs the packet is the 0.
   */
  const uint8_t packet[] = {
      0x6f, 0xff, 0xf8, 0x5f, 0x00, 0x38, 0x11, 0x40, 0x20, 0x01, 0x0d, 0xb8,
      0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
      0x20, 0x01, 0x0d, 0xb8, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x20, 0xd1, 0x00, 0x16, 0x33, 0x00, 0x38, 0x1b, 0xe9,
      0x48, 0x02, 0x84, 0x82, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
      0xb2, 0x56, 0x34, 0x33, 0x62, 0x3d, 0x55, 0x0d, 0x02, 0x0a, 0x0b, 0x0c,
      0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
      0xd2, 0x14, 0xab, 0xef, 0xff, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64};
  const size_t packet_byte_len = sizeof(packet);

  const uint8_t expected_schc_packet[] = {
      0x06, 0x7d, 0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c, 0x23,
      0xc4, 0x15, 0x8d, 0x0f, 0x78, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
      0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0xf1, 0x0a,
      0xbe, 0xf7, 0x06, 0x17, 0x96, 0xc6, 0xf6, 0x16, 0x40};
  const size_t expected_schc_packet_byte_len = sizeof(expected_schc_packet);

  schc_packet_byte_len =
      compress(schc_packet, schc_packet_max_byte_len, DI_UP, packet,
               packet_byte_len, context, context_byte_len);

  assert(schc_packet_byte_len == expected_schc_packet_byte_len);
  assert(memcmp(schc_packet, expected_schc_packet, schc_packet_byte_len) == 0);

  pool_dealloc(schc_packet, schc_packet_max_byte_len);
}

/* ********************************************************************** */

void test_rule_descriptor_1(const uint8_t* context,
                            const size_t   context_byte_len) {
  uint8_t*     schc_packet = (uint8_t*) pool_alloc(sizeof(uint8_t) * 100);
  const size_t schc_packet_max_byte_len = sizeof(uint8_t) * 100;
  size_t       schc_packet_byte_len;

  /**
   * @brief Perform SCHC compression on packet (DI = UP) using context.
   *
   * @details The Rule Descriptor which matchs the packet is the 1.
   */
  const uint8_t packet[] = {
      0x6f, 0x4f, 0xf8, 0x5f, 0x00, 0x38, 0x11, 0x40, 0x20, 0x01, 0x0d, 0xb8,
      0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
      0x20, 0x01, 0x0d, 0xb8, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x20, 0xd1, 0x00, 0x16, 0x33, 0x00, 0x38, 0x1b, 0xb8,
      0x48, 0x02, 0x84, 0xb3, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
      0xb2, 0x56, 0x34, 0x33, 0x62, 0x3d, 0x55, 0x0d, 0x02, 0x0a, 0x0b, 0x0c,
      0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
      0xd2, 0x14, 0xab, 0xef, 0xff, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64};
  const size_t packet_byte_len = sizeof(packet);

  const uint8_t expected_schc_packet[] = {
      0x29, 0xe7, 0xe8, 0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe1,
      0x1e, 0x20, 0xac, 0x68, 0x7b, 0xc0, 0x50, 0x58, 0x60, 0x68, 0x70,
      0x78, 0x80, 0x88, 0x90, 0x98, 0xa0, 0xa8, 0xb0, 0xb8, 0xc7, 0x88,
      0x55, 0xf7, 0xb8, 0x30, 0xbc, 0xb6, 0x37, 0xb0, 0xb2, 0x00};
  const size_t expected_schc_packet_byte_len = sizeof(expected_schc_packet);

  schc_packet_byte_len =
      compress(schc_packet, schc_packet_max_byte_len, DI_UP, packet,
               packet_byte_len, context, context_byte_len);

  assert(schc_packet_byte_len == expected_schc_packet_byte_len);
  assert(memcmp(schc_packet, expected_schc_packet, schc_packet_byte_len) == 0);

  pool_dealloc(schc_packet, schc_packet_max_byte_len);
}

/* ********************************************************************** */

void test_rule_descriptor_2(const uint8_t* context,
                            const size_t   context_byte_len) {
  uint8_t*     schc_packet = (uint8_t*) pool_alloc(sizeof(uint8_t) * 100);
  const size_t schc_packet_max_byte_len = sizeof(uint8_t) * 100;
  size_t       schc_packet_byte_len;

  /**
   * @brief Perform SCHC compression on packet (DI = UP) using context.
   *
   * @details The Rule Descriptor which matchs the packet is the 2.
   */
  const uint8_t packet[] = {
      0x60, 0x4f, 0xf8, 0x5f, 0x00, 0x38, 0x11, 0x40, 0x20, 0x01, 0x0d, 0xb8,
      0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
      0x20, 0x01, 0x0d, 0xb8, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x20, 0xd1, 0x00, 0x16, 0x33, 0x00, 0x38, 0xa0, 0x64,
      0x48, 0x02, 0x00, 0x07, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
      0xb2, 0x56, 0x34, 0x33, 0x62, 0x3d, 0x55, 0x0d, 0x02, 0x0a, 0x0b, 0x0c,
      0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
      0xd2, 0x14, 0xab, 0xef, 0xff, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64};
  const size_t packet_byte_len = sizeof(packet);

  const uint8_t expected_schc_packet[] = {
      0x40, 0x98, 0x00, 0x3f, 0xa0, 0x00, 0x81, 0x01, 0x82, 0x02, 0x83,
      0x03, 0x84, 0x78, 0x82, 0xb1, 0xa1, 0xef, 0x01, 0x41, 0x61, 0x81,
      0xa1, 0xc1, 0xe2, 0x02, 0x22, 0x42, 0x62, 0x82, 0xa2, 0xc2, 0xe3,
      0x1e, 0x21, 0x57, 0xde, 0xe0, 0xc2, 0xf2, 0xd8, 0xde, 0xc2, 0xc8};
  const size_t expected_schc_packet_byte_len = sizeof(expected_schc_packet);

  schc_packet_byte_len =
      compress(schc_packet, schc_packet_max_byte_len, DI_UP, packet,
               packet_byte_len, context, context_byte_len);

  assert(schc_packet_byte_len == expected_schc_packet_byte_len);
  assert(memcmp(schc_packet, expected_schc_packet, schc_packet_byte_len) == 0);

  pool_dealloc(schc_packet, schc_packet_max_byte_len);
}

/* ********************************************************************** */

void test_rule_descriptor_3(const uint8_t* context,
                            const size_t   context_byte_len) {
  uint8_t*     schc_packet = (uint8_t*) pool_alloc(sizeof(uint8_t) * 100);
  const size_t schc_packet_max_byte_len = sizeof(uint8_t) * 100;
  size_t       schc_packet_byte_len;

  /**
   * @brief Perform SCHC compression on packet (DI = UP) using context.
   *
   * @details The Rule Descriptor which matchs the packet is the 3.
   */
  const uint8_t packet[] = {
      0x6b, 0xcf, 0xed, 0xcb, 0x00, 0x38, 0x11, 0x40, 0x20, 0x01, 0x0d, 0xb8,
      0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
      0x20, 0x01, 0x0d, 0xb8, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x20, 0xd1, 0x00, 0x16, 0x33, 0x00, 0x38, 0xa0, 0x6c,
      0x48, 0x02, 0xff, 0xfe, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
      0xb2, 0x56, 0x34, 0x33, 0x62, 0x3d, 0x55, 0x0d, 0x02, 0x0a, 0x0b, 0x0c,
      0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
      0xd2, 0x14, 0xab, 0xef, 0xff, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64};
  const size_t packet_byte_len = sizeof(packet);

  const uint8_t expected_schc_packet[] = {
      0x77, 0x9f, 0xdb, 0x96, 0x90, 0x05, 0xff, 0xfd, 0xe8, 0x00, 0x20, 0x40,
      0x60, 0x80, 0xa0, 0xc0, 0xe1, 0x16, 0x5e, 0x20, 0xac, 0x68, 0x67, 0xe3,
      0x0c, 0x47, 0xaa, 0xa1, 0xb0, 0x05, 0xef, 0x01, 0x41, 0x61, 0x81, 0xa1,
      0xc1, 0xe2, 0x02, 0x22, 0x42, 0x62, 0x82, 0xa2, 0xc2, 0xe3, 0x1a, 0x50,
      0x29, 0xe2, 0x15, 0x7d, 0xee, 0x0c, 0x2f, 0x2d, 0x8d, 0xec, 0x2c, 0x80};
  const size_t expected_schc_packet_byte_len = sizeof(expected_schc_packet);

  schc_packet_byte_len =
      compress(schc_packet, schc_packet_max_byte_len, DI_UP, packet,
               packet_byte_len, context, context_byte_len);

  assert(schc_packet_byte_len == expected_schc_packet_byte_len);
  assert(memcmp(schc_packet, expected_schc_packet, schc_packet_byte_len) == 0);

  pool_dealloc(schc_packet, schc_packet_max_byte_len);
}

/* ********************************************************************** */

void test_rule_descriptor_4(const uint8_t* context,
                            const size_t   context_byte_len) {
  uint8_t*     schc_packet = (uint8_t*) pool_alloc(sizeof(uint8_t) * 100);
  const size_t schc_packet_max_byte_len = sizeof(uint8_t) * 100;
  size_t       schc_packet_byte_len;

  /**
   * @brief Perform SCHC compression on packet (DI = DW) using context.
   *
   * @details The Rule Descriptor which matchs the packet is the 4.
   */
  const uint8_t packet[] = {
      0x6b, 0xcf, 0xed, 0xcb, 0x00, 0x38, 0x11, 0x40, 0x20, 0x01, 0x0d, 0xb8,
      0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
      0x20, 0x01, 0x0d, 0xb8, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x20, 0xd1, 0x00, 0x16, 0x33, 0x00, 0x38, 0xa0, 0x6c,
      0x48, 0x02, 0xff, 0xfe, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
      0xb2, 0x56, 0x34, 0x33, 0x62, 0x3d, 0x55, 0x0d, 0x02, 0x0a, 0x0b, 0x0c,
      0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
      0xd2, 0x14, 0xab, 0xef, 0xff, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64};
  const size_t packet_byte_len = sizeof(packet);

  const uint8_t expected_schc_packet[] = {
      0x8d, 0x79, 0xfd, 0xb9, 0x60, 0x07, 0x02, 0x28, 0x04, 0x00, 0x21,
      0xb7, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x64, 0x00, 0x21, 0xb7, 0x00, 0x01, 0x40, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x1a, 0x20, 0x02, 0xc6,
      0x60, 0x07, 0x14, 0x0d, 0x89, 0x00, 0x5f, 0xff, 0xc0, 0x20, 0x40,
      0x60, 0x80, 0xa0, 0xc0, 0xe1, 0x16, 0x4a, 0xc6, 0x86, 0x6c, 0x47,
      0xaa, 0xa1, 0xa0, 0x41, 0x41, 0x61, 0x81, 0xa1, 0xc1, 0xe2, 0x02,
      0x22, 0x42, 0x62, 0x82, 0xa2, 0xc2, 0xe3, 0x1a, 0x42, 0x95, 0x7d,
      0xff, 0xee, 0x0c, 0x2f, 0x2d, 0x8d, 0xec, 0x2c, 0x80};
  const size_t expected_schc_packet_byte_len = sizeof(expected_schc_packet);

  schc_packet_byte_len =
      compress(schc_packet, schc_packet_max_byte_len, DI_DW, packet,
               packet_byte_len, context, context_byte_len);

  assert(schc_packet_byte_len == expected_schc_packet_byte_len);
  assert(memcmp(schc_packet, expected_schc_packet, schc_packet_byte_len) == 0);

  pool_dealloc(schc_packet, schc_packet_max_byte_len);
}

/* ********************************************************************** */

int main(void) {
  init_memory_pool();

  test_coap_option_extended();
  test_with_compute();

  destroy_memory_pool();

  printf("All tests passed !\n");

  return 0;
}